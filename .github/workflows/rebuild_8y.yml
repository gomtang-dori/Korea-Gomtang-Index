name: rebuild_8y

on:
  workflow_dispatch:
    inputs:
      start:
        description: "F04 Put/Call 백필 시작일 (YYYYMMDD)"
        required: true
        default: "20180101"
      cache_buffer_days:
        description: "API/휴일 버퍼 (days) - F04에는 보통 불필요하지만 입력 유지"
        required: true
        default: "0"

jobs:
  rebuild_f04_only:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      PYTHONPATH: src

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Set date range (F04)
        shell: bash
        run: |
          set -euo pipefail
          END="$(date -u -d '1 day ago' +%Y%m%d)"
          echo "BACKFILL_START=${{ inputs.start }}" >> "$GITHUB_ENV"
          echo "BACKFILL_END=$END" >> "$GITHUB_ENV"
          echo "CACHE_BUFFER_DAYS=${{ inputs.cache_buffer_days }}" >> "$GITHUB_ENV"
          echo "PUTCALL_CACHE_PATH=data/cache/putcall_ratio.parquet" >> "$GITHUB_ENV"

      # -------------------------------------------------------
      # F04 Put/Call (KRX) : 분기 루프 + 분기마다 체크포인트 push
      # -------------------------------------------------------
      - name: Backfill F04 Put/Call per quarter with checkpoint push
        shell: bash
        env:
          KRX_AUTH_KEY: ${{ secrets.KRX_AUTH_KEY }}
          KRX_EQSOP_URL: ${{ secrets.KRX_EQSOP_URL }}
          KRX_EQKOP_URL: ${{ secrets.KRX_EQKOP_URL }}
          FINAL_END: ${{ env.BACKFILL_END }}
          CACHE_PATH: ${{ env.PUTCALL_CACHE_PATH }}
        run: |
          set -euo pipefail

          # ---- helpers ----
          ymd() { date -u -d "$1" +%Y%m%d; }

          q_start() {
            local y="$1"; local q="$2"
            case "$q" in
              1) echo "${y}0101" ;;
              2) echo "${y}0401" ;;
              3) echo "${y}0701" ;;
              4) echo "${y}1001" ;;
              *) echo "bad quarter: $q" >&2; exit 1 ;;
            esac
          }

          q_end() {
            local y="$1"; local q="$2"
            local ns_y="$y"; local ns_q="$((q+1))"
            if [ "$ns_q" -eq 5 ]; then ns_q=1; ns_y="$((y+1))"; fi
            local next_start
            next_start="$(q_start "$ns_y" "$ns_q")"
            ymd "${next_start} -1 day"
          }

          min_ymd() { [ "$1" -le "$2" ] && echo "$1" || echo "$2"; }
          max_ymd() { [ "$1" -ge "$2" ] && echo "$1" || echo "$2"; }

          START_INPUT="${{ env.BACKFILL_START }}"
          START_YEAR="${START_INPUT:0:4}"
          START_MONTH="${START_INPUT:4:2}"

          if   [ "$START_MONTH" -ge 1 ] && [ "$START_MONTH" -le 3 ]; then START_Q=1
          elif [ "$START_MONTH" -ge 4 ] && [ "$START_MONTH" -le 6 ]; then START_Q=2
          elif [ "$START_MONTH" -ge 7 ] && [ "$START_MONTH" -le 9 ]; then START_Q=3
          else START_Q=4
          fi

          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          y="$START_YEAR"
          q="$START_Q"

          while true; do
            qs="$(q_start "$y" "$q")"
            qe="$(q_end "$y" "$q")"

            run_s="$(max_ymd "$qs" "$START_INPUT")"
            run_e="$(min_ymd "$qe" "$FINAL_END")"

            if [ "$run_s" -le "$run_e" ]; then
              echo "=== F04 Put/Call backfill: ${y}Q${q} (${run_s}~${run_e}) ==="

              BACKFILL_START="$run_s" BACKFILL_END="$run_e" PUTCALL_CACHE_PATH="$CACHE_PATH" \
                python src/caches/cache_putcall.py

              # checkpoint commit/push: putcall cache only
              git add "$CACHE_PATH" || true
              if git diff --staged --quiet; then
                echo "No changes to checkpoint for ${y}Q${q}."
              else
                git stash push -u -m "actions-stash-before-rebase" || true
                git fetch origin main
                git pull --rebase origin main
                git stash pop || true

                git add "$CACHE_PATH" || true
                if git diff --staged --quiet; then
                  echo "No staged changes after rebase for ${y}Q${q}."
                else
                  git commit -m "Checkpoint F04 putcall cache ${y}Q${q} (${run_s}~${run_e})" || true
                  git push origin HEAD:main
                fi
              fi
            else
              echo "Skip ${y}Q${q} (out of range)."
            fi

            if [ "$qe" -ge "$FINAL_END" ]; then
              echo "Reached FINAL_END=$FINAL_END at ${y}Q${q}."
              break
            fi

            q=$((q+1))
            if [ "$q" -eq 5 ]; then q=1; y=$((y+1)); fi

            # 안전장치
            if [ "$y" -gt 2026 ] || { [ "$y" -eq 2026 ] && [ "$q" -gt 4 ]; }; then
              echo "Stop at boundary."
              break
            fi
          done

      - name: Show min/max date (F04 cache)
        shell: bash
        env:
          TARGETS: "data/cache/putcall_ratio.parquet"
          DATE_COL_CANDIDATES: "date,Date,basDt,BASE_DT"
        run: |
          set -euo pipefail
          python - << 'PY'
          import os
          from pathlib import Path
          import pandas as pd

          targets = [t.strip() for t in os.getenv("TARGETS","").split(",") if t.strip()]
          cand_cols = [c.strip() for c in os.getenv("DATE_COL_CANDIDATES","date").split(",") if c.strip()]

          def pick_date_col(df):
            for c in cand_cols:
              if c in df.columns:
                return c
            for c in df.columns:
              if "date" in c.lower():
                return c
            return None

          print("=== [min/max date] ===")
          for t in targets:
            p = Path(t)
            if not p.exists():
              print(f"[MISS] {t}")
              continue
            df = pd.read_parquet(p)
            dc = pick_date_col(df)
            if not dc:
              print(f"[NO_DATE_COL] {t} cols={list(df.columns)[:25]}")
              continue
            s = pd.to_datetime(df[dc], errors="coerce").dropna()
            print(f"[OK] {t} rows={len(df)} date_col={dc} min={s.min()} max={s.max()}")
          PY
